# MPI basic
## 缓冲区
MPI环境定义了3种缓冲区：应用缓冲区(每个线程的程序的缓冲区)、系统缓冲区、用户向系统注册的缓冲区（通信缓冲区）。  
- 应用缓冲区  
就是在程序中开辟的内存空间的地址，也就上面代码中的sb和rb分别代表发送数据和接收数据的缓冲区地址，本质上呢就是一个数组的首地址。  
- 系统缓冲区  
是MPI环境为通信所准备的存储空间。类似于一个数据中转站，应用缓冲区的数据在系统缓冲区中复制 入和出，即发送数据的时候从应用缓冲区将数据复制到系统缓冲区，接收数据的时候从系统缓冲区复制到应用缓冲区。 
- 用户向系统注册的缓冲区  
是指用户使用某些API（如MPI_Bsend）时，在程序中显式申请的存储空间，然后注册到MPI环境中,供通讯所用。

## 4 modes of communication
- 标准模式(standard mode)   
由MPI 系统来决定是先将消息拷贝至一个缓冲区然后立即返回(此时消息的发送由MPI 系统在后台进行)，还是等待将数据发送出去后再返回。大部分MPI系统预留了一定大小的缓冲区，当发送的消息长度小于缓冲区大小时会将消息拷贝到缓冲区然后立即返回，否则则当部分或全部消息发送完成后才返回。标准模式发送操作是非局部的，因为它的完成需要与接收方联络。标准模式阻塞型发送函数是MPI_Send。  
(标准模式 类似于 智能选择"缓冲模式+同步模式")  
数据流向: 发送缓冲区->接收缓冲区 或 发送缓冲区->系统缓冲区->接收缓冲区 (由系统选择)  
- 缓冲模式(buffered mode)   
MPI 系统将消息拷贝至一个用户提供的缓冲区然后立即返回，消息的发送由MPI 系统在后台进行。用户必须确保所提供的缓冲区足以容下采用缓冲模式发送的消息。缓冲模式发送操作是局部的，因为函数不需要与接收方联络即可立即完成(返回)。缓冲模式阻塞型发送函数为MPI_Bsend。  
数据流向: 发送缓冲区->用户定义缓冲区->接收缓冲区  
- 同步模式(synchronous mode)   
在标准模式的基础上要求确认接收方已经开始接收数据后函数调用才返回。显然，同步模式的发送是非局部的。同步模式阻塞型发送函数为MPI_Ssend。  
数据流向: 发送缓冲区->接收缓冲区  
- 就绪模式(ready mode)   
调用就绪模式发送时必须确保接收方已经处于就绪状态(正在等待接收该消息)，否则将产生一个错误。该模式设立的目的是在一些以同步方式工作的并行系统上由于发送时可以假设接收方已经准备好接收而减少一些握手开销。如果一个使用就绪模式的MPI 程序是正确的，则将其中所有就绪模式的消息发送改为标准模式后也应该是正确的。就绪模式阻塞型发送函数为MPI_Rsend。  
数据流向: 发送缓冲区->接收缓冲区  

发送缓冲区->接收缓冲区 is faster than 发送缓冲区->中间缓冲区->接收缓冲区  

## types of MPI calls
- local
一个过程(procedure)的完成,只依赖于本地执行的进程(process).不需要通信!  
- non-local
一个过程(procedure)的完成可能需要其他进程(process)上的过程(procedure).需要通信!  

- blocking
阻塞通信,要等待所发送的消息在被'安全'保存或处理之后,函数才会返回,执行下一条语句. 否则,一致卡在这个语句.  
'安全'保存和处理表示, 在接下来的操作中, 上一次的数据不会被破坏和影响.  
例如:  
如果信息大小小于系统缓冲区, 信息被完整保存在系统缓冲区, 可以认为是安全保存. 继续执行下一条语句.   
如果信息大小大于系统缓冲区, 无法被完整保存, 但是此时有recv接收,当所有数据都被系统缓冲区安全保存或者被recv安全处理之后, 继续执行下一条语句.  

造成死锁的例子:  
1. 两个process, 都先recv,再send. 这种情况下, 由于recv一直接收不到数据,程序一直停留在recv. 无法执行下一条的send, 又导致recv永远接收不到语句.  
2. 两个process, 都先send,再recv, 如果系统缓存区不够大, 两个process的send都有溢出的数据需要被处理, (等待对方的recv), 然而对方的send也卡住, recv无法执行, 导致死锁.  

- non-blocking  
非阻塞型通信函数的调用总是立即返回，而实际操作由 MPI 系统在后台进行。用户必须随后调用其他函数来等待或查询操作完成的实际情况。  
在操作完成之前对相关数据区的操作是不安全的，因为随时可能与正在后台进行的操作发生冲突。  
非阻塞型函数的调用是局部的。  
在有些并行系统上，通过非阻塞型通信可以实现计算与通信的重叠进行，从而提高并行效率。   

- collective  
聚合通信, 一组内所有进程(all processes)都需要参与的函数调用.  

